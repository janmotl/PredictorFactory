<?xml version="1.0" encoding="utf-8" standalone="yes"?>

<pattern>
	<name>WOE</name>
	<description>Weight of evidence.

		In comparison to the textbook formulation this implementation takes care of:
			1) Missing values (they are treated as a separate category)
			2) Zero probabilities (with Laplace correction)
			3) Polynomial target
			4) Leaking target values (by using leave one out trick - it is fast as we just subtract the current target value from the global results)

		Note that WoE still ignores confidence of the estimates. For example, if we have 2 positive samples and
		5 negative samples, we get the same WoE as if we had 2000 positive samples and 5000 negative samples.
		Intuitively, the second scenario should result into a value further from zero. Nevertheless, this problem is
		partially solved with leave-one-out: with small sample size, the variance of the estimate is higher.

		The implementation is from: https://qizeresearch.wordpress.com/2014/05/21/utilize-woe-to-replace-dummy-variables/

		To avoid division by zero and logarithm of zero in evaluation of WoE we use the Laplace correction.
		Laplacean correction is from: http://shigglesblog.blogspot.com/2013/07/weight-of-evidence.html

		A different correction schema:
			http://support.sas.com/documentation/cdl/en/prochp/66704/HTML/default/viewer.htm#prochp_hpbin_details02.htm
		Based on the empirical comparison performed by Maros Spak, the implemented correction schema performs on average
		by 0.5% better than the correction implemented by SAS. This difference was consistent across
		different models (decision tree, logistic regression, naive Bayes), different metrics (classification accuracy,
		f-measure, AUC) and different datasets (7 datasets). From the theoretical point of view, the implemented
		correction produces scores that can be interpreted as a probability (e.g. they sum to 1), while the SAS score
		cannot be interpreted as a probability because the scores do not sum to 1 (at least for finite count of samples).

		The empirical evidence suggests that Laplacean correction improves AUC by 5 percent points.
			See: http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1918410

		Target value is always treated as a string because databases automatically cast numbers to strings, if necessary.
		But databases do not automatically cast strings to numbers. Hence, treating the target value as a string works
		for both, numerical and string targets.

		NOTE: We do not calculate WoE for NULL category in the attribute.
		For examples of the implementation see http://support.sas.com/resources/papers/proceedings13/095-2013.pdf
		or https://cran.r-project.org/web/packages/Causata/Causata.pdf
		Missing values should be treated as a special category as explained at: http://multithreaded.stitchfix.com/blog/2015/08/13/weight-of-evidence/

		NOTE: We do not calculate WoE for NULL target value as it just unnecessarily increases the count
		of rows in the predictor.

		Multi-class WoE: http://dspace.library.uu.nl/bitstream/handle/1874/11641/c4.pdf

		NOTE: Training and testing data are getting mixed -> expect overly optimistic estimates.

		NOTE: WORKS ONLY ON BINARY TARGETS! -> produce a column for each target class

		NOTE: Is expected to fail on regression tasks.

		NOTE: Oracle may require specifying logarithm base.

		Some other predictors are mentioned in ACORA (Provost).
	</description>
	<example>
		Log ods for customer's cellphone brand.
	</example>
	<author>Jan Motl</author>
	<date>2015-03-08</date>
	<code> SELECT a.@base
				, woe.woe @columnName
			FROM @propagatedTable a
			JOIN (
				 SELECT @nominalColumn
				 	  , {fn log(((sum(case when @targetName='@targetValue' then 1.0 else 0 end)+1)/avg(total.total_default))
				 / ((sum(case when @targetName &lt;&gt; '@targetValue' then 1.0 else 0 end)+1)/avg(total.total_nondefault))) } *100
				 as woe
				 FROM @propagatedTable
					  , (SELECT sum(case when @targetName='@targetValue' then 1.0 else 0 end)+2 as total_default
					          , sum(case when @targetName &lt;&gt; '@targetValue' then 1.0 else 0 end)+2 as total_nondefault
					  FROM @propagatedTable) total
		         WHERE @targetName IS NOT NULL
				 GROUP BY @nominalColumn
				 ) woe
			ON a.@nominalColumn = woe.@nominalColumn
			GROUP BY a.@base, woe.woe
	</code>
	<cardinality>1</cardinality>
</pattern>
