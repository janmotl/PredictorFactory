<?xml version="1.0" encoding="utf-8" standalone="yes"?>

<pattern>
	<name>Ratio of missing values v2</name>
	<description>
		Real-world data commonly contain contain missing values. And sometimes they are not missing at random. 
		Thus we mine them.

		This pattern has a good predictive power/runtime ratio.

		NOTE: WHAT SHOULD WE RETURN INSTEAD OF NULL?

		NOTE: TEST IT ON COMPOSITE IDS.

		Technical note: Count(*) counts all values regardless of NULLs, while count(@column) excludes NULLs.
		An alternative way how to calculate the predictor is to use "case then" but that is slower.
		
		Do not confuse this pattern with aggregation or num_children. Aggregation is only for numerical attributes. 
		And num_children works on table level. Also note that direct_field takes care of the scenario where 
		cardinality==1. 
	</description>
	<example>
		In Titanic dataset passengers with missing age are more likely to die. This is because information about 
		the customers' age was obtained after Titanic's sinking. And it was easier to obtain this information from 
		the survivals than from the victims.   
	</example>
	<author>Jan Motl</author>
	<date>2014-12-30</date>
	<code> SELECT t1.@baseId
				, t1.@baseDate
				, t1.@baseTarget
				, coalesce(result, 0) AS "@columnName"
		FROM @baseTable t1
		LEFT JOIN (
			SELECT @baseId
				   , @baseDate
				   , (count(*) - count(@column)) / count(*) AS result
			  FROM @propagatedTable
			  GROUP BY @baseId, @baseDate
		) t2
		ON t1.@baseId = t2.@baseId AND t1.@baseDate = t2.@baseDate
	</code>
	<parameter key="@column" value="@nominalColumn, @numericalColumn, @temporalColumn"/>
	<cardinality>n</cardinality>
</pattern>
